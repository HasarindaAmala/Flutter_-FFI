

import 'dart:ffi';
import 'dart:ffi' as ffi;
import 'dart:io' show Platform;
import 'dart:typed_data';
import 'dart:ui';
import 'package:ffi/ffi.dart';
import 'c_plugin_bindings_generated.dart';

/// Loads the correct dynamic library for the current platform.
final DynamicLibrary _dylib = () {
  if (Platform.isAndroid || Platform.isLinux) {
    // Android & Linux use a .so
    return DynamicLibrary.open('libc_plugin.so');
  } else if (Platform.isWindows) {
    // Windows uses a .dll
    return DynamicLibrary.open('c_plugin.dll');
  } else if (Platform.isMacOS || Platform.isIOS) {
    // On Apple platforms, plugins are linked into the main process
    return DynamicLibrary.process();
  }
  throw UnsupportedError('Unsupported platform: ${Platform.operatingSystem}');
}();

/// The FFI bindings generated by ffigen, based on c_plugin_bindings.h
final NativeLibrary _bindings = NativeLibrary(_dylib);

/// A simple wrapper around the native `int sum(int a, int b)` function.
int sum(int a, int b) => _bindings.sum(a, b);

/// Calls the native `const char* get_opencv_version()` function
/// and converts the returned C string to a Dart `String`.
String getOpenCvVersion() {
  // 1. Get it as a Pointer<Char>
  final Pointer<ffi.Char> charPtr = _bindings.get_opencv_version();
  if (charPtr == nullptr) {
    throw StateError('Failed to retrieve OpenCV version');
  }

  // 2. Cast it to Pointer<Utf8>
  final Pointer<Utf8> utf8Ptr = charPtr.cast<Utf8>();

  // 3. Convert to Dart string
  return utf8Ptr.toDartString();
}

List<Rect> findBrightRegions(
    Uint8List nv21,
    int width,
    int height,
    int threshold,
    int maxRegions,
    ) {
  final dataPtr = calloc<Uint8>(nv21.length);
  dataPtr.asTypedList(nv21.length).setAll(0, nv21);

  final bboxPtr  = calloc<Int>(maxRegions * 4);
  final countPtr = calloc<Int>();

  _bindings.detect_bright_regions(
    dataPtr,
    width,
    height,
    threshold,
    maxRegions,
    bboxPtr,
    countPtr,
  );

  final count = countPtr.value;
  final regions = <Rect>[];
  for (var i = 0; i < count; i++) {
    final x = bboxPtr[i * 4 + 0];
    final y = bboxPtr[i * 4 + 1];
    final w = bboxPtr[i * 4 + 2];
    final h = bboxPtr[i * 4 + 3];
    regions.add(Rect.fromLTWH(
      x.toDouble(),
      y.toDouble(),
      w.toDouble(),
      h.toDouble(),
    ));
  }

  calloc.free(dataPtr);
  calloc.free(bboxPtr);
  calloc.free(countPtr);

  return regions;
}

/// Checks if the LED in [roi] is ON (>5% bright pixels).
bool checkLedOn(
    Uint8List nv21,
    int width,
    int height,
    int threshold,
    Rect roi,
    ) {
  final dataPtr = calloc<Uint8>(nv21.length);
  dataPtr.asTypedList(nv21.length).setAll(0, nv21);

  final result = _bindings.detect_led_on(
    dataPtr,
    width,
    height,
    threshold,
    roi.left.toInt(),
    roi.top.toInt(),
    roi.width.toInt(),
    roi.height.toInt(),
  );

  calloc.free(dataPtr);
  return result == 1;
}
List<double> processFrameBrightness(
    Uint8List yPlane,
    int width,
    int height,
    int rowStride,
    Rect roi,
    ) {
  // copy Y plane
  final ptr = calloc<Uint8>(yPlane.length);
  ptr.asTypedList(yPlane.length).setAll(0, yPlane);

  // prepare output buffer
  final outBuf = calloc<Double>(3);

  // call native
  _bindings.process_frame(
    ptr,
    width,
    height,
    rowStride,
    roi.left.toInt(),
    roi.top.toInt(),
    roi.width.toInt(),
    roi.height.toInt(),
    outBuf,
  );

  // read results
  final current = outBuf[0];
  final minVal  = outBuf[1];
  final maxVal  = outBuf[2];

  calloc.free(ptr);
  calloc.free(outBuf);

  return [current, minVal, maxVal];
}



