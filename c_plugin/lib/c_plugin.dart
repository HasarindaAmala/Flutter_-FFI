

import 'dart:ffi';
import 'dart:ffi' as ffi;
import 'dart:io' show Platform;
import 'dart:typed_data';
import 'dart:ui';
import 'package:ffi/ffi.dart';
import 'c_plugin_bindings_generated.dart';

/// Loads the correct dynamic library for the current platform.
final DynamicLibrary _dylib = () {
  if (Platform.isAndroid || Platform.isLinux) {
    // Android & Linux use a .so
    return DynamicLibrary.open('libc_plugin.so');
  } else if (Platform.isWindows) {
    // Windows uses a .dll
    return DynamicLibrary.open('c_plugin.dll');
  } else if (Platform.isMacOS || Platform.isIOS) {
    // On Apple platforms, plugins are linked into the main process
    return DynamicLibrary.process();
  }
  throw UnsupportedError('Unsupported platform: ${Platform.operatingSystem}');
}();

/// The FFI bindings generated by ffigen, based on c_plugin_bindings.h
final NativeLibrary _bindings = NativeLibrary(_dylib);

/// A simple wrapper around the native `int sum(int a, int b)` function.
int sum(int a, int b) => _bindings.sum(a, b);

/// Calls the native `const char* get_opencv_version()` function
/// and converts the returned C string to a Dart `String`.

List<Rect> findBrightRegions(
    Uint8List nv21,
    int width,
    int height,
    int threshold,
    int maxRegions,
    ) {
  final dataPtr = calloc<Uint8>(nv21.length);
  dataPtr.asTypedList(nv21.length).setAll(0, nv21);

  final bboxPtr  = calloc<Int>(maxRegions * 4);
  final countPtr = calloc<Int>();

  _bindings.detect_bright_regions(
    dataPtr,
    width,
    height,
    threshold,
    maxRegions,
    bboxPtr,
    countPtr,
  );

  final count = countPtr.value;
  final regions = <Rect>[];
  for (var i = 0; i < count; i++) {
    final x = bboxPtr[i * 4 + 0];
    final y = bboxPtr[i * 4 + 1];
    final w = bboxPtr[i * 4 + 2];
    final h = bboxPtr[i * 4 + 3];
    regions.add(Rect.fromLTWH(
      x.toDouble(),
      y.toDouble(),
      w.toDouble(),
      h.toDouble(),
    ));
  }

  calloc.free(dataPtr);
  calloc.free(bboxPtr);
  calloc.free(countPtr);

  return regions;
}

/// Checks if the LED in [roi] is ON (>5% bright pixels).
bool checkLedOn(
    Uint8List nv21,
    int width,
    int height,
    int threshold,
    Rect roi,
    ) {
  final dataPtr = calloc<Uint8>(nv21.length);
  dataPtr.asTypedList(nv21.length).setAll(0, nv21);

  final result = _bindings.detect_led_on(
    dataPtr,
    width,
    height,
    threshold,
    roi.left.toInt(),
    roi.top.toInt(),
    roi.width.toInt(),
    roi.height.toInt(),
  );

  calloc.free(dataPtr);
  return result == 1;
}
List<double> processFrameBrightness(
    Uint8List yPlane,
    int width,
    int height,
    int rowStride,
    Rect roi,
    ) {
  // copy Y plane
  final ptr = calloc<Uint8>(yPlane.length);
  ptr.asTypedList(yPlane.length).setAll(0, yPlane);

  // prepare output buffer
  final outBuf = calloc<Double>(3);

  // call native
  _bindings.process_frame(
    ptr,
    width,
    height,
    rowStride,
    roi.left.toInt(),
    roi.top.toInt(),
    roi.width.toInt(),
    roi.height.toInt(),
    outBuf,
  );

  // read results
  final current = outBuf[0];
  final minVal  = outBuf[1];
  final maxVal  = outBuf[2];

  calloc.free(ptr);
  calloc.free(outBuf);

  return [current, minVal, maxVal];
}

List<double> processFrameColor({
  required Uint8List yPlane,
  required Uint8List uPlane,
  required Uint8List vPlane,
  required int width,
  required int height,
  required int count,
  required int yRowStride,
  required int uvRowStride,
  required int uvPixelStride,
  required Rect roi,
}) {
  // copy YUV planes
  final yPtr = calloc<Uint8>(yPlane.length)..asTypedList(yPlane.length).setAll(0, yPlane);
  final uPtr = calloc<Uint8>(uPlane.length)..asTypedList(uPlane.length).setAll(0, uPlane);
  final vPtr = calloc<Uint8>(vPlane.length)..asTypedList(vPlane.length).setAll(0, vPlane);

  // output buffer of 7 doubles
  final outPtr = calloc<Double>(7);

  _bindings.process_frame_color(
    yPtr, uPtr, vPtr,
    width, height,count,
    yRowStride, uvRowStride, uvPixelStride,
    roi.left.toInt(), roi.top.toInt(),
    roi.width.toInt(), roi.height.toInt(),
    outPtr,
  );

  final results = List<double>.generate(7, (i) => outPtr[i]);

  calloc.free(yPtr);
  calloc.free(uPtr);
  calloc.free(vPtr);
  calloc.free(outPtr);

  return results;
}

/// Computes [hue, sat, val] over the ROI by building a hue histogram.
/// Returns a List<double> of length 3.
List<double> detectFrameColorPrecise({
  required Uint8List yPlane,
  required Uint8List uPlane,
  required Uint8List vPlane,
  required int width,
  required int height,
  required int yRowStride,
  required int uvRowStride,
  required int uvPixelStride,
  required Rect roi,
}) {
  final yLength = yPlane.length;
  final uLength = uPlane.length;
  final vLength = vPlane.length;
  final Pointer<Uint8> yPtr = calloc<Uint8>(yLength)
    ..asTypedList(yLength).setAll(0, yPlane);
  final Pointer<Uint8> uPtr = calloc<Uint8>(uLength)
    ..asTypedList(uLength).setAll(0, uPlane);
  final Pointer<Uint8> vPtr = calloc<Uint8>(vLength)
    ..asTypedList(vLength).setAll(0, vPlane);

  // Allocate output buffer of length 3
  final Pointer<Double> outPtr = calloc<Double>(3);

  _bindings.detect_frame_color_precise(
    yPtr,
    uPtr,
    vPtr,
    width,
    height,
    yRowStride,
    uvRowStride,
    uvPixelStride,
    roi.left.toInt(),
    roi.top.toInt(),
    roi.width.toInt(),
    roi.height.toInt(),
    outPtr,
  );

  final hue = outPtr[0];
  final sat = outPtr[1];
  final val = outPtr[2];

  calloc.free(yPtr);
  calloc.free(uPtr);
  calloc.free(vPtr);
  calloc.free(outPtr);

  return [hue, sat, val];
}
// ----------------------------------------------------------------------------
// HSV classification
// ----------------------------------------------------------------------------

/// Calls the native `int classify_hsv_color(double hue, double sat, double val)`.
/// Returns an integer code (e.g. 0=unknown, 1=red, etc.) depending on your C++ implementation.
int classifyHsvColor(double hue, double sat, double val) {
  return _bindings.classify_hsv_color(hue, sat, val);
}

// ----------------------------------------------------------------------------
// Single-pixel YUV â†’ HSV conversion
// ----------------------------------------------------------------------------

/// Converts a single YUV pixel (Y, U, V in [0..255]) to HSV ([hue, sat, val]).
/// Returns a List<double> of length 3.
List<double> yuvPixelToHsv(int yVal, int uVal, int vVal) {
  final Pointer<Double> outHue = calloc<Double>();
  final Pointer<Double> outSat = calloc<Double>();
  final Pointer<Double> outVal = calloc<Double>();

  _bindings.yuvpixel_to_hsv_c(
    yVal.toUnsigned(8),
    uVal.toUnsigned(8),
    vVal.toUnsigned(8),
    outHue,
    outSat,
    outVal,
  );

  final hue = outHue.value;
  final sat = outSat.value;
  final val = outVal.value;

  calloc.free(outHue);
  calloc.free(outSat);
  calloc.free(outVal);

  return [hue, sat, val];
}



